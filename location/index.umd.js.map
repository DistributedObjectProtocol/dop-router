{"version":3,"file":"index.umd.js","sources":["../src/location/index.js"],"sourcesContent":["import { register, set, del, collect, intercept, isRegistered } from 'dop'\n\nconst enc = encodeURIComponent\n\nexport function createLocation(url, object, prop) {\n    let shallWeEmit = false\n    let location\n    let urlparsed = parse(url)\n    prop = prop || 'location'\n\n    if (object !== null && typeof object == 'object') {\n        if (isRegistered(object)) set(object, prop, urlparsed)\n        else {\n            object[prop] = urlparsed\n            object = register(object)\n        }\n\n        location = object[prop]\n    } else location = register(urlparsed)\n\n    location.toString = function() {\n        return location.href\n    }\n\n    intercept(location, (mutation, object) => {\n        if (!shallWeEmit) {\n            if (mutation.prop === 'href') {\n                object.href = mutation.oldValue\n                pushState(mutation.value)\n                setHref(getWindowLocation())\n            } else if (mutation.prop === 'pathname') {\n                let href = mutation.value\n                    .split('/')\n                    .map(enc)\n                    .join('/')\n                if (mutation.value[0] !== '/') href = '/' + href\n                href = href + location.search + location.hash\n                object.pathname = mutation.oldValue\n                pushState(href)\n                setHref(getWindowLocation())\n            } else if (mutation.prop === 'search') {\n                let href =\n                    mutation.value[0] === '?'\n                        ? mutation.value.substr(1)\n                        : mutation.value\n                href = href\n                    .split('&')\n                    .map(param => {\n                        let splited = param.split('=')\n                        param = enc(splited[0] || '')\n                        if (splited.hasOwnProperty(1))\n                            param += '=' + enc(splited[1])\n                        return param\n                    })\n                    .join('&')\n\n                href = location.pathname + '?' + href + location.hash\n                object.search = mutation.oldValue\n                pushState(href)\n                setHref(getWindowLocation())\n            } else if (mutation.prop === 'hash') {\n                let href =\n                    mutation.value[0] === '#'\n                        ? mutation.value\n                        : '#' + mutation.value\n                href = location.pathname + location.search + href\n                object.hash = mutation.oldValue\n                pushState(href)\n                setHref(getWindowLocation())\n            } else if (mutation.prop === 'path') {\n                let href =\n                    '/' +\n                    mutation.value.map(enc).join('/') +\n                    location.search +\n                    location.hash\n                pushState(href)\n                setHref(getWindowLocation(), mutation)\n            } else if (mutation.prop === 'query') {\n                let href,\n                    prop,\n                    query = mutation.value,\n                    search = []\n                for (prop in query)\n                    search.push(enc(prop) + '=' + enc(query[prop]))\n\n                href =\n                    location.pathname + '?' + search.join('&') + location.hash\n                pushState(href)\n                setHref(getWindowLocation())\n            } else\n                // origin, protocol, domain\n                object[mutation.prop] = mutation.oldValue\n        }\n\n        return shallWeEmit\n    })\n\n    intercept(location.path, (mutation, object) => {\n        if (!shallWeEmit) {\n            let path = location.path\n            object[mutation.prop] = enc(path[mutation.prop])\n            let href =\n                '/' +\n                path.filter(p => p !== undefined).join('/') +\n                location.search +\n                location.hash\n            if (href !== location.pathname) {\n                pushState(href)\n                setHref(getWindowLocation(), mutation)\n            }\n        }\n        return shallWeEmit\n    })\n\n    intercept(location.query, (mutation, object) => {\n        if (!shallWeEmit) {\n            let href,\n                query = location.query,\n                search = [],\n                prop = mutation.prop\n            // Is true if is not a delete\n            if (mutation.hasOwnProperty('value')) {\n                let propenc = enc(mutation.prop)\n                let valueenc = enc(mutation.value)\n                delete object[mutation.prop]\n                object[propenc] = valueenc\n            }\n            for (prop in query) search.push(prop + '=' + query[prop])\n            href = location.pathname + '?' + search.join('&') + location.hash\n\n            pushState(href)\n            setHref(getWindowLocation(), mutation)\n        }\n        return shallWeEmit\n    })\n\n    function setHref(href, mutation) {\n        let newlocation = parse(href)\n        newlocation.href = getHref(newlocation)\n        let collector = collect()\n        if (mutation !== undefined) collector.mutations.push(mutation)\n        shallWeEmit = true\n        set(location, 'href', newlocation.href)\n        set(location, 'pathname', newlocation.pathname)\n        set(location, 'search', newlocation.search)\n        set(location, 'hash', newlocation.hash)\n\n        // path\n        newlocation.path.forEach((path, index) =>\n            set(location.path, index, path)\n        )\n        set(location.path, 'length', newlocation.path.length)\n\n        // query\n        let prop,\n            newquery = newlocation.query,\n            query = location.query\n        for (prop in newquery) set(query, prop, newquery[prop])\n        for (prop in query) if (!newquery.hasOwnProperty(prop)) del(query, prop)\n\n        // emit\n        shallWeEmit = false\n        collector.emit()\n    }\n\n    // when user click back/forward on browser or change the hash\n    if (window)\n        window.addEventListener('popstate', function() {\n            setHref(getWindowLocation())\n        })\n\n    return location\n}\n\nfunction pushState(url, state, title) {\n    // if nodejs ... todo\n    window.history.pushState(state, title, url)\n}\n\nfunction getWindowLocation() {\n    // if nodejs ... todo\n    return window.location.href\n}\n\nfunction getHref(location) {\n    return location.pathname + location.search + location.hash\n}\n\nfunction parse(url) {\n    let match = /((.*):\\/\\/([^/#?]+))?([^?#]*)([^#]*)(.*)?/.exec(\n            decodeURIComponent(url)\n        ),\n        query = {},\n        location = {\n            origin: match[1],\n            protocol: match[2],\n            host: match[3],\n            pathname: match[4],\n            path: match[4].split('/').filter(item => item.length > 0),\n            search: match[5],\n            query: query,\n            hash: match[6] || ''\n        }\n\n    location.href = getHref(location)\n\n    if (location.search.length > 1) {\n        location.search\n            .substr(1)\n            .split('&')\n            .forEach(item => {\n                if (item.length > 0) {\n                    let equal = item.indexOf('=')\n                    equal > -1\n                        ? (location.query[item.substr(0, equal)] = item.substr(\n                              equal + 1\n                          ))\n                        : (location.query[item] = '')\n                }\n            })\n    }\n\n    return location\n}\n"],"names":["enc","encodeURIComponent","pushState","url","state","title","history","getWindowLocation","window","location","href","getHref","pathname","search","hash","parse","match","exec","decodeURIComponent","split","filter","item","length","substr","forEach","equal","indexOf","query","object","prop","shallWeEmit","urlparsed","setHref","mutation","newlocation","collector","collect","undefined","mutations","push","path","index","set","newquery","hasOwnProperty","del","emit","isRegistered","register","toString","oldValue","value","map","join","splited","param","p","propenc","valueenc","addEventListener"],"mappings":"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"}