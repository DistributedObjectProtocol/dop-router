{"version":3,"file":"index.umd.js","sources":["../src/location/index.js"],"sourcesContent":["import { register, set, del, collect, intercept, isRegistered } from 'dop'\n\nconst enc = encodeURIComponent\n\nexport function createLocation(url, object, prop) {\n    let shallWeEmit = false\n    let location\n    let urlparsed = parse(url)\n    prop = prop || 'location'\n\n    if (object !== null && typeof object == 'object') {\n        if (isRegistered(object)) set(object, prop, urlparsed)\n        else {\n            object[prop] = urlparsed\n            object = register(object)\n        }\n\n        location = object[prop]\n    } else location = register(urlparsed)\n\n    location.toString = function() {\n        return location.href\n    }\n\n    intercept(location, (mutation, object) => {\n        if (!shallWeEmit) {\n            if (mutation.prop === 'href') {\n                object.href = mutation.oldValue\n                pushState(mutation.value)\n                setHref(getWindowLocation())\n            } else if (mutation.prop === 'pathname') {\n                let href = mutation.value\n                    .split('/')\n                    .map(enc)\n                    .join('/')\n                if (mutation.value[0] !== '/') href = '/' + href\n                href = href + location.search + location.hash\n                object.pathname = mutation.oldValue\n                pushState(href)\n                setHref(getWindowLocation())\n            } else if (mutation.prop === 'search') {\n                let href =\n                    mutation.value[0] === '?'\n                        ? mutation.value.substr(1)\n                        : mutation.value\n                href = href\n                    .split('&')\n                    .map(param => {\n                        let splited = param.split('=')\n                        param = enc(splited[0] || '')\n                        if (splited.hasOwnProperty(1))\n                            param += '=' + enc(splited[1])\n                        return param\n                    })\n                    .join('&')\n\n                href = location.pathname + '?' + href + location.hash\n                object.search = mutation.oldValue\n                pushState(href)\n                setHref(getWindowLocation())\n            } else if (mutation.prop === 'hash') {\n                let href =\n                    mutation.value[0] === '#'\n                        ? mutation.value\n                        : '#' + mutation.value\n                href = location.pathname + location.search + href\n                object.hash = mutation.oldValue\n                pushState(href)\n                setHref(getWindowLocation())\n            } else if (mutation.prop === 'path') {\n                let href =\n                    '/' +\n                    mutation.value.map(enc).join('/') +\n                    location.search +\n                    location.hash\n                pushState(href)\n                setHref(getWindowLocation(), mutation)\n            } else if (mutation.prop === 'query') {\n                let href,\n                    prop,\n                    query = mutation.value,\n                    search = []\n                for (prop in query)\n                    search.push(enc(prop) + '=' + enc(query[prop]))\n\n                href =\n                    location.pathname + '?' + search.join('&') + location.hash\n                pushState(href)\n                setHref(getWindowLocation())\n            } else\n                // origin, protocol, domain\n                object[mutation.prop] = mutation.oldValue\n        }\n\n        return shallWeEmit\n    })\n\n    intercept(location.path, (mutation, object) => {\n        if (!shallWeEmit) {\n            let path = location.path\n            object[mutation.prop] = enc(path[mutation.prop])\n            let href =\n                '/' +\n                path.filter(p => p !== undefined).join('/') +\n                location.search +\n                location.hash\n            if (href !== location.pathname) {\n                pushState(href)\n                setHref(getWindowLocation(), mutation)\n            }\n        }\n        return shallWeEmit\n    })\n\n    intercept(location.query, (mutation, object) => {\n        if (!shallWeEmit) {\n            let href,\n                query = location.query,\n                search = [],\n                prop = mutation.prop\n            // Is true if is not a delete\n            if (mutation.hasOwnProperty('value')) {\n                let propenc = enc(mutation.prop)\n                let valueenc = enc(mutation.value)\n                delete object[mutation.prop]\n                object[propenc] = valueenc\n            }\n            for (prop in query) search.push(prop + '=' + query[prop])\n            href = location.pathname + '?' + search.join('&') + location.hash\n\n            pushState(href)\n            setHref(getWindowLocation(), mutation)\n        }\n        return shallWeEmit\n    })\n\n    function setHref(href, mutation) {\n        let newlocation = parse(href)\n        newlocation.href = getHref(newlocation)\n        let collector = collect()\n        if (mutation !== undefined) collector.mutations.push(mutation)\n        shallWeEmit = true\n        set(location, 'href', newlocation.href)\n        set(location, 'pathname', newlocation.pathname)\n        set(location, 'search', newlocation.search)\n        set(location, 'hash', newlocation.hash)\n\n        // path\n        newlocation.path.forEach((path, index) =>\n            set(location.path, index, path)\n        )\n        set(location.path, 'length', newlocation.path.length)\n\n        // query\n        let prop,\n            newquery = newlocation.query,\n            query = location.query\n        for (prop in newquery) set(query, prop, newquery[prop])\n        for (prop in query) if (!newquery.hasOwnProperty(prop)) del(query, prop)\n\n        // emit\n        shallWeEmit = false\n        collector.emit()\n    }\n\n    // when user click back/forward on browser or change the hash\n    if (window)\n        window.addEventListener('popstate', function() {\n            setHref(getWindowLocation())\n        })\n\n    return location\n}\n\nfunction pushState(url, state, title) {\n    // if nodejs ... todo\n    window.history.pushState(state, title, url)\n}\n\nfunction getWindowLocation() {\n    // if nodejs ... todo\n    return window.location.href\n}\n\nfunction getHref(location) {\n    return location.pathname + location.search + location.hash\n}\n\nfunction parse(url) {\n    let match = /((.*):\\/\\/([^/#?]+))?([^?#]*)([^#]*)(.*)?/.exec(url),\n        query = {},\n        location = {\n            origin: match[1],\n            protocol: match[2],\n            host: match[3],\n            pathname: match[4],\n            path: match[4].split('/').filter(item => item.length > 0),\n            search: match[5],\n            query: query,\n            hash: match[6] || ''\n        }\n\n    location.href = getHref(location)\n\n    if (location.search.length > 1) {\n        location.search\n            .substr(1)\n            .split('&')\n            .forEach(item => {\n                if (item.length > 0) {\n                    let equal = item.indexOf('=')\n                    equal > -1\n                        ? (location.query[item.substr(0, equal)] = item.substr(\n                              equal + 1\n                          ))\n                        : (location.query[item] = '')\n                }\n            })\n    }\n\n    return location\n}\n"],"names":["enc","encodeURIComponent","pushState","url","state","title","history","getWindowLocation","window","location","href","getHref","pathname","search","hash","parse","match","exec","split","filter","item","length","substr","forEach","equal","indexOf","query","object","prop","shallWeEmit","urlparsed","setHref","mutation","newlocation","collector","collect","undefined","mutations","push","path","index","set","newquery","hasOwnProperty","del","emit","isRegistered","register","toString","oldValue","value","map","join","splited","param","p","propenc","valueenc","addEventListener"],"mappings":"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"}